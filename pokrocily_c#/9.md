# 9. přednáška
### procházení stromu enumerací
```
B : IEnumerable<int>
  .GetEnumerator() --> IEtor<int>
                        .MoveNext()
```
- vypadá to krásně jako sekvenční průchod stroemm, když si naimplentuju GetEnumerator
- v každém kroku foreache se při MoveNext přidávají odkazy na další enumeráory, vniká cesta enumerátorů
![struktura enumerátorů při procházení stromu do hloubky](retez_enumeratoru_9_pred.jpg)
- je to strašný overkill, přibývá hromada enumerátorů
- chceme to udělat nějak lépe
- můžeme jakožto programátoři nové třídy A využívající B úplně zničit člověka, který programjue B tím, že pro svoje účely po něm budeme chtít pořád další funkce, třeba průchod do indexu 5 etc
### dva přístupy
```
A:
  foreach
    MoveNext z B
      podmínka
```
nebo
```
B:
  indexOf ...
    while ...
      ...
      podmínka A
      ...
```
- můžeme použít rozhraní `IComparable` na podmínku, ale spíš by se nám hodilo hypotetické `IComparision<T>` s `bool Compare<T x>`, porotže nemáme ten druhý člen z `IComparable Compare(T x, T y)`
> připomenutí: **IComparision je fiktivní**
```
A : IComparision<int>
```
- **to nechceme** - rozšiřovali bychom tím kontrakt, ale je to implementační detail
```
:::uvnitř A:::
private class LessThan5 : IComparision<int> {
  bool Compare(int i)
    return i < 5;
}
```
- zase je overkill tam pořád vyrábět instance té privátní třídy
## delegáti
- chytré pointery na funkce
- striktně referenční typy
- může být i vhnízděný
```
delegate int D (string s);
D d = default; <=> null
D d = new D(m)
            ^^ m je odkaz na metodu
               !!! NE m(), to je volání
```
- dědí od `System.MulticastDelegate`
