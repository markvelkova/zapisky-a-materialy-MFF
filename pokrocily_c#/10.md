# 10. p콏edn치코ka, pokro캜il칳 c#
## deleg치ti pokra캜ov치n칤
- cht캩li jsme minule kus algoritmu vyt치hnout jinam, parametrizovat ji deleg치tem
```
class A
    ProcessList() {
        int index = list.FindIndex(GreaterThanFive)
    }
    private static bool IsGreaterThanFive(int x) => x >5
```
- mohlo by se st치t, 쬰 zm캩n칤m vnit콏ek metody `GreaterThanfive` t콏eba na $7$, ale zapomenu upravit n치zev
- nebo na to n캩kdo s치hne, nebo si ji pou쬴je n캩kde a t칤m p콏estane b칳t implementa캜n칤m detailem
- v캩ci pro jeden 콏치dek n치m leakuj칤 d치l do k칩du, to nechceme
<br>--> **lambda funkce**

## lambda funkce - "anonymn칤 funkce"
- m치 jm칠no na 칰rovni CIL, ale je generov치no p콏eklada캜em, je tam vn칤m치na jako norm치ln칤 funkce
### z치kladn칤 koncept
- `static [parametry] => [t캩lo]`
- **pozor!! jen ta 코ipi캜ka neznamen치 lambda funkci!!!**, je to prost캩 zkr치cen칳 z치pis, lambda funkci pozn치m z toho, 쬰 tam nen칤 n치zev funkce
```
class A
    ProcessList() {
        int index = list.FindIndex(static (int x) => {return x > 5;})
    }
```
- v t칠hle f치zi je to jen syntaktik 코ugr
- v prehistorii (C# 3) se tam psalo `static delegate [parametry] => [t캩lo]`
- m콢쬰 b칳t i voidov치 `static (int x) => x + 1`
- nemus칤 m칤t typ parametry `static x => x + 1`, v CIL je to otypov치no implicitn캩 p콏eklada캜em
- nemus칤 m칤t parametry `static () => Console.WriteLine("kokos")`
- bu캞 mus칤 m칤t v코echny parametry ur캜en칳 typ, nebo 쮂멳n칠 (nejde `(x, int y)`)
- m콢쬰 se dosadit do deleg치ta `Func<int,int> f1 = static x => x + 1`, implicitn캩 to tam p콏eklada캜 po코칠f칤
- `Func<int,double> f1 = static x => x + 1` OK - je konverze, p콏eklada캜 si ji v k칩du vygeneruje, vznikne `double <parent>b__0_0(int x)`
- `Func<double,int> f1 = static x => x + 1` BAD - nen칤 implicitn칤 konverze z double na int, vzniklo by `int <parent>b__0_0(double x)`
- `Func<double,int> f1 = static x => (int)x + 1` - OK
- **ned치 se explicitn캩 zvolit typ n치vratov칠 hodnoty v lambda funkci!**
- lambda funkce kv콢li stati캜nosti nem치 stav
### p콏칤klad - mapov치n칤, jak to p콏eklada캜 d캩l치
```
public static class Seuence {
    public sttaic IEnumerable<S> MapAll<T,S>(this IEnumerable<T>, mapper n캩co s S)
}


List<Customer> customers = GeCustomerList();
IEnumerable<string> names = customers.MapAll(static c => c.name)
```
- p콏eklada캜 tam d캩l치 pom캩rn캩 netrivi치ln칤 pr치ci
```
IEnumerable<string> names = Sequence.MapAll(customers, static c => c.name)
```
```
Sequence.MapAll<Customer, S>(customers, static c => c.name)
```
```

Sequence.MapAll<Customer, S>(customers, static (Customer c) => c.name)
```
zkus칤 string
```
Sequence.MapAll<Customer, string>(customers, static (Customer c) => c.name)
```
funguje, hur치
- mus칤 b칳t ale jasn치 cesta
- dal by se tam pou쮂셦 object, ale bylo by to k ni캜emu
----
----
## rela캜n칤 datab치ze
- kdy bereme kolekci jako mno쬴nu dat
- je to tabulka s 콏치dky a sloupci
- jeden 콏치dek reprezentuje jednu entitu, v programu by to byla jedna instance t콏칤dy, t콏eba Person
- tabulku lze vn칤mat jako kolekci t캩ch entit
- **SQL query** se dotazuj칤 t칠 tabulky, t콏eba
  - `SELECT * FROM PEOPLE WHERE Age>=18`
  - ne콏칤kaj칤 algoritmus, jak to d캩lat, tak쬰 ten server si to mus칤 n캩jak efektivn캩 vy콏e코it, popisujeme to deklarativn캩
  - tahle my코lenka deklarativn칤ho z치pisu d치v치 smysl i jinde v programov치n칤
  
## LINQ - Language Integrated Queries
- **na 칰rovni C# je to pouze syntaxe**, nedefinuje to 쮂멳nou s칠mantiku
- definuje to, co m콢쬰me zapsat, ale ne, co to znamen치游뗶
- `from x in [zdroj_dat] [klauzule A B C]`
- x je pseudoprom캩nn치 reprezentuj칤c칤 entitu
- jako kdyby to byl 
```
JEN P콎EDSTAVA!!!!
foreach (x in [zdroj_dat])
    x -> A -> B -> C --> v칳sledek
```
```
from c in customers where c.City == "London"" select c.Name
p콏elo쮂 se na
customers.Where(c=> c.City == "London").Select(c=>c.Name)
```
- **C# jen garantuje, 쬰 to naho콏e se p콏elo쮂 na to dole, to dole se ale mus칤 p콏elo쬴t stejn캩 jako kdybychom napsali rovnou to dole**
- parametry t캩ch vnit콏n칤ch lambda funkc칤 nejsou sd칤len칠 a je 칰pln캩 jedno, jak se jmenuj칤
### s칠mantika LINQ
- m콢쬰me si napsat vlastn칤
#### p콏칤코ery
```
class Creature {
    public string Name {get; set;}
    public int OrderBy(Predicate<Creature> predicate) {
        if (predicate(this))
            zabij p콏칤코eru
            return 1
        else
            nech ji 쮂셦
            return 0
    }
}

var emilCreature = new Creature {Name = "Emil"}
var shelobCreature = new Creature {Name = "Shelob"}

int creaturesKilled = from c in emilCreature orderby c.Name.StartsWith("S") select c;
// emil p콏e쬴je
int creaturesKilled = from c in shelobCreature orderby c.Name.StartsWith("S") select c;
// shelob um콏e
```
- ty metody mohou vracet cokoli, mus칤m ale p콏i 콏et캩zen칤 mylse tna to, na 캜em se n치m ty predik치ty vlastn캩 volaj칤
- t콏eba pokud `Where` na `Nothing` vr치t칤 `int` a j치 na tom vol치m zase `Where`, tak se to nep콏elo쮂, proto쬰 `int` nem치 `Where`
- ta kasak치da funkc칤 prost캩 mus칤 b칳t validn칤
- zase jednou p콏ekladov칳 duck-typing
### LINQ to Objects 
- p콏edp콏ipraven치 sada extension methods
- `using System.Linq`
```
static class Enumerable {
    Where <T>(this IE<T>, Predicate<T>)
}
```
- jsou to extern칤 metody, nerozum칤 implementa캜n칤m deail콢m
- pokud si nap칤코eme vlastn칤 metodu, pou쬴je se ta, proto쬰 extension metody se hledaj칤 a jako posledn칤)
<br> `var q = ds.Where(...).Where(...).Select(...)`
- oper치tory se d캩l칤 na dv캩 kategorie
  - deffered execution 
  - 
### deffered execution
  - zavol치 se metoda, ale neud캩l치 se ta v캩c
  - t콏eba `Where` nefiltruje, ale vyrob칤 objekt n캩jak칠ho typu `WhereEnumerable`, kter칳 si pamatuje referenci na zdroj
  - pak se zavol치 metoda `Where` zase na tom `WhereEnumerable`, m치 dokaz na sv콢j zdroj
  - na to se vol치 `Select`, vyrob칤 `SelectEnumerable`, m치 odkaz na sv콢j zdroj
  - zat칤m nikdo nevolal deleg치ty ani se neptal kolekce, co m치
  - tyhle objekty iplementuj칤 `IEnumerable<to co vrac칤m>`
  - ud캩l치me:
  ```
  foreach (i in q) {
      e = getEnumerator() na ten SelectEnumerable
      e.MoveNext()
          zdroj.getEnumerator() tedy na druhy WhereEnumerable
          vol치m na n캩j MoveNext()
              zdroj.getEnumerator() tedy na prvni WhereEnumerable
              vol치m na n캩j MoveNext()
                  zdroj.getEnumerator() enumerator dataSourcu
                  vol치m na n캩j MoveNext()
  }
  ```
  - v코echno si to pamatuje reference na to dal코칤
  - vr치cen칠 v캩ci se z hlubiny propaguj칤 nahoru, kdy nespln칤 n캩co v polovin캩, opajue se vol치n칤 `MoveNext()` dole
  - je to **lazy evaluation**
  - ne v코echny metody se takhle mohou volat, t콏eba `OrderBy` ned치v치 smysl

![fotka tabule s grafick칳m zn치zorn캩n칤m p콏칤kladu v칳코e](IMG_20250423_170132_edit_1022805714924360.jpg)
<br>
#### na po콏ad칤 z치le쮂
- kdy d치m `Where` a za to `OrderBy` - nejd콏칤v vybere, pak t콏칤d칤
- kdy d치m `OrderBy` a za to `Where` - nejd콏칤v t콏칤d칤 v코e, pak vyb칤r치
- prvn칤 mo쬹ost je rychlej코칤
- p콏i vol치n칤 na jin칠 v캩ci definovan칠 se jen vyrob칤 nov치 krabi캜ka, kter치 ukazuje na konec 콏et칤zku
     




