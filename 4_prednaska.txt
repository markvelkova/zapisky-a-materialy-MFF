implementace foru a ifu v assembleru - easy

REGISTRY
- nejrychlejší pamì, kterou máme
- rùzné instrukce pracují s rùznými typy registrù
o obecné  - slouží ke všemu
o speciální integerové na aritmetiku, nejsou k nièemu jinému
o floatové 
o adresové - jen pro adresaci
o stavové 
o skokové, branch - nastavím si tam adresu, kam skáèu
o predikáty - jednobitvé, instrukce jsou podmínìny predikáty
o aplikaèní - divné, pro konkrétní instrukce
o systémové
o vektorové

x86
- aliasing - al ah ax - zmena casti meni i ty jiné - nesikovné
- akumulator, base (jako základ pro adresaci), counter (nkrát - n je v C), data
- SI, DI - source/destination index adresace v øetìzzcových instrukcích
- BP adresace na zásobník
- SP stack pointer - vršek zásobníku
- je flagový rozdíl mezi znaménkovou a bezznaménkovou architekturou
- IP instruction pointer

MIPS
- 32 bit, r0-r31
- r0 vždycky 0, zápisy se ignorují
- r31 zanmená instrukci jal, je tam uložená hodnota return
- ostatní jsou si rovnocenné, ale použití definováno ABI
- frame pointer - kus zásobníku, kde má funkce své promìnné atd
- global pointer
- chybí hardwarový zásobník
- flagy nejsou
- PC - program counter
- musím si rozmyslet, co zachová funkce volaná z funkce volající 
    - extrém - uložím všechny, které chci použít na zásobník, použiju, 
               pak to tam vrátím a volající funkce má všechno zachované
    - extrém2 - neuložím nic, pøepíšu všechno
- nìkteré registry se schovávají, nìkteré ne - temporaries a saved temporaries




ABI = application binary interface
- doporuèení od výrobce doprovázející ISA
- jak se to má používat, když se to nedodržuje, 
  ->mohou být problémy pøi používání jiných pøekladaèù
- pokud se aplikace a knihovna kompilují zvláš 
  ->mìly by stejným pøekladaèem nebo pøekladaèi splòujícímí ABI
- jak vypadá zásobník, jak používat které registry
- 32bit x86 to nemìlo

OPERACE
- dvojoperandové - x86 eax+=ebx
- trojoperandové - MIPS, co+co kam
- add - tøi registry
- addi - konstanta 16bitová, znaménkovì se rozšíøí na 32
- sub
- subi
- and
- or
- xor
- nor
- sll/slr nìco = nìco << o kolik
- sra - arithmetic, zachovává znaménko
loady, story
- load word (32bit)
- lw $rd, imm16($rs) = R[rd] = M[R[rs]+signedext32(imm16)}]
- imm kvùli pøístupu do struktury
- store word sw
- lb load bytes
- pøepíšu celý registr, do vršku se doplní nuly
- lbu ignoruje znaménkovost
- sb store bytes
moves
- li $rd imm32
    - je to pseudoinstrukce, uloží 32bit konstantu do registru
    - není reálnì implementovaná - isntrukce sama má 32 bitù
    - nepoužívá se u malých konstant
    - místo toho ori reg, zero, konst
- move
skoky
- j addr
- jr $rs
- jal addr
    - jump and link
    - R[31] = PC+4
    - PC = addr
    - takže mám uloženou návratovou adresu
podmínìné skoky
- beq reg reg addr branch if equal
- bne analogicky
- chybí porovnání na vìtší menší v jumpech
testing
- slt/sltu reg1, reg2, reg3  - ucko je unsigned
    - když reg2<reg3 reg1=1, jinak reg1 = 0
- tady se vyuzije nula registr
- slti/sltiu
    - stli/u reg1, reg2, imm







