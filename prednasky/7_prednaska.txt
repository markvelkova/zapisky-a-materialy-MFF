CACHE
- vyplatí se jenom, pokud se budu ptát znova na stejná vstupní data
- funguje i softwarová
- hardwarová by mìla být pro programátora neviditelná
- stale je øádovì pomalejší než pøístup do registru

cache line
- cache je organizovana v øádcích, vždy se to dìlá po celé cache line, po kratších kouscích to nejde
- je zarovnaná
- vždycky to je násobek øádky pamìti
- vìtšinou 64B

úspìšnost
- 97% cache hit
- 3%  cache miss - plný pøístup do pamìti, naètu celou øádku z pamìti do cache
                 - když je úplnì plná cache, musím nìco zahodit
- pøi pøepisování - zapisuje se jen o cache, její stav skutecny nemusí odpovídat mému obrazu
- ^^do pamìti se zapíše, až když se to má smazat z cache
- koherence cachí - aby rùzné procesory mìly stejnou pøedstavu o stavu cache
    - protokol MESSI
    - ne vsechny procesory ji mají !!! pozor
    - C# nebo Java si to øeší, C++ ne
- hieararchie cachí - L1, L2, L3 (rostoucí)
- hodnì používaná data se bublají do L1 cache, pak se zase propadají zpátky
- pøi cache miss se to hodí rovnou do L1

ASOCIATIVNÍ PAMÌ
""tak jsem lhal, že to bude pozdìjš. bude to teï""
- øádka je dvojice klíè a hodnota
- dotaz na cache - je tam klíè? 
- když je v asociativní pamìti, vrátím hodnotu
- klíèe jsou adresy cache line odpovídající fyzické adrese na RAM
- hodnota je tìch 64B
- dotaz je extrmnì rychlý O(1)
- nedá se realizovat softwarovì, je to velmi drahé hardwarovì

NUMA - non uniform memory access
- kolem 8-16 jader pøestává fungovat von Neumannovská architektura, 
  pøetížená sdílená sbìrnice SMP (symetrický multiprocessing)
- pøešlo se na tohle
- sockety, každý má vlastní RAM, kterou ovládá svým øadièem, ty pamìti jsou hápané jako jeden velký adresový prostor
- procesory jsou pospojované vysokorychlostní sbìrnicí, takže jsou všechny dostupné odevšad
- pošlu žádost na konkrétní procesor, on data pøeète a pošle
- z pohledu programátora to vypadá úplnì normálnì
- maximálnì 8 socketù, cena roste exponenciálnì
- NUMA factor - jak je pomalejší pøístup do ostatních pamìtí, porovnání vùèi normální rychlosti


---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------


GRAMATIKA
- pravidla, urèuje syntaxi

PØEKLADAÈ
- zdrojový kód -> preprocessor -> .pp -> compiler -> .asm -> assembler -> .obj -> linker(pøidají se knihovny) -> spustitelný kód
- ^^pro C, preprocesor vezme # a nahradí ten øádek kódem té knihovny, definem atd atd - pøekladaè typu text-text
- kompiler - pøeklad do assembleru, zase textovì (dnes už se nedìlá), rozumìl instrukcím, ale setnì to byl pøeklad tet-text
- asembler - už z toho vyrobí binární zápis instrukcí
- linker - splácá to dokupy, vznikne jeden spustitelný soubor

.OBJ
- binární obraz toho jednoho zdrojáku

LINKER
- knihovny 
  statické (rovnou pøidám) jako jeden balík - zjednodušení, prostì jen balík objektù
  dynamické 
        (zapamatuju, že tam nìkde jsou ty funkce, místo volání funkce je speciální kód volající dynamickou knihovnu, 
        která není pøilinkovaná k .exe souboru (je pøidaná mimo, nebo už je v poèítaèi)
        linker si z toho vytahá hlavièky a samotná knihovna je bokem, není ve výsledném kódu, dává se o tam až pøi spuštìní
        - pomalejší, menší, možno mìnit nezávisle na tom, jak to slinkujeme
- linkování - vezme objecty a najde, co se používá (rekurzivnì), to pospojuje
            - relokace
- loader - èást operaèního systému, vezme spustitelný program v pøesnì definovaném formátu
         - linux nerozumí windows exe souborúm a tak
         - naète to do pamìti a pustí to
         = stává se z toho proces
         - program je mrtvá vìc na disku, proces je živý
         








