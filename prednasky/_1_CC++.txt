C/++

statické jazyky
efektivnì namapované na strojové instrukce
dobré pro velké vìci i malé èipy
explicitní management dynamické pamìti

#include SE CELÉ NAHRADÍ obsahem té knihovny

ZÁPIS
CELÝCH ÈÍSEL
decimální
- jsou znaménková, píšu normálnì
hexadecimální
- pøedpona 0x
binární
- pøedpona 0b
osmièková
- pøedpona prostì 0
FLOATÙ - normálnì
BOOLEAN - true, false
STRINGÙ - v uvozovkách
CHARÙ - v apostrofech, pokud je v jiném typu než char, tak je to int

ESCAPE SEKVENCE
\n LF
\r CR
\t TAB - nejbližší násobek 8
\\ jedno zpìtné lomítko
\' apostrof
\" uvozovka
\xab char hodnoty 0xab - na divnoznaky

TYPY PROMÌNNÝCH
základní
- char dnes 8-bitù, na unicody jiné typy 
- int znaménkové ARDUINO MÁ INT 16BIT, RECODEX 32BIT
modifikátory
- short (libovolný èíselný typ, poèet bitù <= int) 16/ard 16
- long (>= int) 64/ard 32
- long long (>= long) 64/ard 64
- mùžu si vynutit int32_t
- signed, unsigned
floatové
- float, double, long double 7-5-4
další
- void, bool (v C _Bool)
velikostní
- size_t - dle poèítaèe, na mém 64bitù, podle pamìového prostoru

IMPLICITNÍ KONVERZE TYPU
- menší pøiøazuju do vìtšího - v pohodì
- vìtší do menšího - varování, potenciální ztráta dat
- pøi operacích je výsledek ten vìtší z tìch dvou, operace se v nìm i provádí
EXPLICITNÍ KONVERZE TYPU, CAST
double d;
float f = (float)d;

PROMÌNNÁ
= pojmenovaná hodnota v pamìti
- deklarace, inicializace (jinak náhodný obsah)
- typ auto
- životnost, viditelnost

ŽIVOTNOST
lokální
- existuje pouze v bloku {}
globální
- libovolná promìnná deklarovaná mimo tìlo fce
- žije po celou dobu programu
- zavoláno už pøed main
- automaticky inicializovaná na nulu

VIDITELNOST
- globální i lokální až od okamžiku inicializace
- nevidím si navzájem do blokù
statické
- static int je lokální s globální životností
- pøi opakovaném volání funkce se hodnota zachovává

________________________________________________________________________________
PØÍKAZY V C A C++
¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
- celý blok {} se chápe jako jeden pøíkaz

IF
- pokud je hodnota rùzná od nuly
- v () mùže být cokoli porovnatelné s nulou

SWITCH
switch (expr pouze int nebo výèet) {
case 0:
    //sth
    break;
case 1:
case 2:
    //spolecny kod pro case 1 a 2
    break;
default:    //když není, neudìlá se nic
    break;
}

WHILE
- jako u ifu, dokud rùzné od nuly, porovnání pøed prvním provedením

DO WHILE
- porovnání až po provedení

FOR
- (inicializace; test; inkrementace - mùže být libovolný výraz)

GOTO
- na návìstí, když potøebuju udìlat break pøes víc úrovní
- NEMÙŽU SKÁKAT MEZI FUNKCEMI
- není rozumné skákat dovnitø o jiného bloku

________________________________________________________________________________
OPARÁTORY A VÝRAZY
^^^^^^^^^^^^^^^^^^
aritmetické
  +,=,*,/,%
  ++,--
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        !!!!   i = 5;                        !!!!
        !!!!   j = ++i; --> i = 6; j = 6;    !!!!
        !!!!   j = i++; --> i = 6; j = 5;    !!!!
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
porovnávací
  <, <=, >=, >, ==, !=
bitové
  ~ ALTGR+1 negace
  & ALTGR+C and
  | ALTGR+W or
  ^ ALTGR+3 xor
  <<, >>    u znaménkového se kopíruje nejvyšší bit
logické
  &&, ||, !
ukazatele
  &, *
pøiøazení
  =, +=, -=, *=, /=, %=, &=, |=, ^=   
  je to poøád výraz - mùžu øetìzit, if (i=5) platí, pokud i !=0
velikostní
  sizeof v bytech
  szeof(int)
  sizepf(i+4) - spoèítá se jen typ, ne výraz
TERNÁRNÍ VÝRAZ
- test ? e1 : e2

________________________________________________________________________________
POLE
^^^^
- nikdo nekontroluje, jestli jsme nesáhli vedle
- inicializace jen èásti: int pole[1000]={1,2,3,};
- u vícerozmìrných uožení po øádcích

STRING
^^^^^^
- pole charù automaticky zakonèené '\0' nulou
- char str[] = "Hippo";
- TOHLE NENÍ STRING char chars[] = {'H', 'i', 'p', 'p', 'o'};
________________________________________________________________________________
ZAROVNÁNÍ PAMÌTI
^^^^^^^^^^^^^^^^
- char kdekoli, int na násobcích 4 etc.
________________________________________________________________________________
STRUKTURA
^^^^^^^^^
- struct point2d {
    int x, y;
  };
- je tam uvnitø padding kvùli zarovnání pamìti
- padding zvenku na zarovnání podle velikosti nejvìtšího datového typu
- pøehazovat se nemùže
- struct data {
    cahr c;
    double d;
    int i;
  };
  c-------
  dddddddd
  iiii----
________________________________________________________________________________

KOSTANTY
^^^^^^^^
const int the_answer = 42; - má místo v pamìti, dá se z toho vzít adresa
cosntexpr int the_answer = 42; - neexistuje v pamìti
#define THE_ANSWER 42 - dìlalo se døív, textovì se nahradí ještì pøed pøekladem
________________________________________________________________________________

VÝÈTOVÉ TYPY
^^^^^^^^^^^^
enum state_t{ nìco1, nìco2, nìco3 }; - céèkové, dostane to int hodnoty

class enum state_t{ nìco1, nìco2, nìco3 }; - c++kové
state_t s = state_t::nìco2

FUNKCE MAIN
¡¡¡¡¡¡¡¡¡¡¡
-je to normální funkce, musí nìco vracet, automaticky sama returnuje 0
-tím zaèíná bìh programu
-nejjednodušší verze bez parametrù
-dva možné parametry - poèet vstupù int argc (velikost pole pøekladaè nezjistí) 
                       a pole stringù char *argv[]

UKAZATELE
^¡^¡^¡^¡^
-jen zviditelnìní situace, která se dìje i v ostatních programovacích jazycích
-prý to není dìsivé, ALE JE TO DÌSIVÉ
-celé bezznaménkové èíslo, které øíká adresu do pamìti
-ví, na co ukazují, takže oèekávají, že adrese je datový typ, na který ukazují
* - ukazatel, & - vzití adresy promìnné
int *pv = &v ...........vezmi adresu v a ulož ji do pv
- d-reference - unární hvìzdièka, musí za ní být ukazatel
*pv = 4 - vloží na místo, kam ukazuje pv, ètyøku
pv = 4 - vloží do pv ètyøku  
-mùžeme udìlat ukazatel na void 
^ pøekladaè neví, na co se ukazuje, mùžeme tam pøiøazovat libovolný typ ukazatele
-velikost není fixovaná, je podle architektury poèítaèe

-pointery a pole jsou to samé
int vals[] = {12,13}; - opravdu se nìkde sežene pamì té velikosti, nemùžu zmìnit
int *vals = {12,13}; - jen promìnná typu pointer, mùžu tam dávat i jiné vìci
 to pole vznikne, ale není pojmenované, pøiøadím jinou hodnotu -> pole zmizí
-pole je ukazatel na zaèátek pole
-stringy fungují skoro stejnì

-s pointery se dá poèítat, ale je to nebezpeèné (jestli už nesaháme nìkam mimo)
	str[i] je ekvivalentní *(str+i)
*(str+i) neznamená, že èíslo se zvýší o jedna, 
  ale o velikost sizeofu typu, na který se ukazuje, takže tøeba u int 4
	while (*str) { //jdu znak po znaku, poslední znak stringu je nula
	 blabla
	 ++str;
	}

-pointerové vìci se ètou zprava

REFERENCE
¡¡¡¡¡¡¡¡¡
-zafixovaný pointer, nedá se s tím dìlat aritmetika
int v = 8;
int &pv = v;   === int *pv = &v; akorát se s tím nedají dìlat brigule
pv = 4; = pøiøazuje na adresu, kam ukazuje pv

FUNKCE
¡¡¡¡¡¡
-parametry se pøedávají hodnotou, když volám, všechny parametry se okopírují
 vzniká nová lokální promìna toho jména
-pokud chci dostat ven funkèní výstupní parametr, musím ji pøedávat ukazatelem
-v C++ se mùže pøedávat jako reference, když tam zapíšu uvnitø funkce, bude to vidìt i venku

VELIKOSTI
~~~~~~~~~
-sizeof vrací velikost v bytech, pozor, ukazatel na pole nezná velikost pole

TØÍDY
%%%%%
-v c++ jsou tøídy a struktury to stejné až na viditelnost zvenku
-ale použití:
struktury - vìci, co mají být zabalíèkované pohromadì
tøídy - drží neviditelný stav objektu a nabízí to veøejné funkce, kterými mùžu ten stav zmìnit
- v c++ je úplnì jasný životní cyklus tøídy
- konstruktor se volá pøi vzniku
- const píšu za funkci, pokud nemìní vìci v tøídì
- destruktor ~class() volá se pøi zániku tøídy
- pøi dosazení jinam se všechno kopíruje, v c# se kopíruje jen reference

